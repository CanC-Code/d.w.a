#include "cpu_shared.h"
#include "../MapperMMC1.h"
#include <android/log.h>

#define LOG_TAG "DWA_DISPATCHER"
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

// External reference to the global mapper defined in native-lib.cpp
extern MapperMMC1 mapper;

// --- RECOMPILED BANK ENTRY POINTS ---
// These namespaces contain the execute_at function generated by the asm-to-c script.
namespace Bank00 { void execute_at(uint16_t pc); }
namespace Bank01 { void execute_at(uint16_t pc); }
namespace Bank02 { void execute_at(uint16_t pc); }
namespace Bank03 { void execute_at(uint16_t pc); }

typedef void (*BankExecFn)(uint16_t);

// Table of function pointers for the 4 available 16KB banks
static const BankExecFn bank_dispatch_table[] = {
    Bank00::execute_at, 
    Bank01::execute_at, 
    Bank02::execute_at, 
    Bank03::execute_at
};

namespace Dispatcher {
    /**
     * Resolves the NES Memory Map for MMC1 and dispatches execution to 
     * the correct recompiled C++ bank.
     */
    void execute_at(uint16_t pc) {
        // MMC1 PRG Banking Modes (from Control Register bits 2 & 3):
        // 0, 1: Switch 32 KB at $8000, ignoring low bit of bank number
        // 2: Fix first bank ($8000) at $8000, and switch 16 KB bank at $C000
        // 3: Fix last bank ($03) at $C000, and switch 16 KB bank at $8000
        uint8_t mode = (mapper.control >> 2) & 0x03;
        uint8_t bank_reg = mapper.prg_bank & 0x0F; 
        uint8_t target_index = 0;

        // Only addresses >= $8000 map to PRG-ROM
        if (pc >= 0x8000) {
            if (pc >= 0xC000) {
                // --- Upper Window: $C000 - $FFFF ---
                switch (mode) {
                    case 0: 
                    case 1: 
                        // 32KB Mode: High bank of the 32KB pair
                        target_index = (bank_reg & 0x0E) | 0x01; 
                        break;
                    case 2: 
                        // $C000 is Switchable
                        target_index = bank_reg; 
                        break;
                    case 3: 
                    default:
                        // $C000 is Fixed to the Last Bank
                        target_index = 3; 
                        break;
                }
            } else {
                // --- Lower Window: $8000 - $BFFF ---
                switch (mode) {
                    case 0: 
                    case 1: 
                        // 32KB Mode: Low bank of the 32KB pair
                        target_index = (bank_reg & 0x0E); 
                        break;
                    case 2: 
                        // $8000 is Fixed to the First Bank
                        target_index = 0; 
                        break;
                    case 3: 
                    default:
                        // $8000 is Switchable
                        target_index = bank_reg; 
                        break;
                }
            }

            // --- CRITICAL BOUNDS CHECK ---
            // Dragon Warrior 1 is 64KB (4 banks). Masking prevents out-of-bounds 
            // access to the bank_dispatch_table during transitions.
            target_index &= 0x03; 

            // Call the recompiled logic for this specific bank
            bank_dispatch_table[target_index](pc);
        } 
        else {
            // RAM/Register Execution: 
            // The NES CPU is at an address < $8000. Recompiled code cannot exist here.
            // We increment reg_PC to avoid a hard hang, though in a perfect 
            // system, an interpreter would take over here.
            reg_PC++; 
        }
    }
}
