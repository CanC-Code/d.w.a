#include "cpu_shared.h"
#include "../MapperMMC1.h"
#include <android/log.h>

#define LOG_TAG "DWA_DISPATCHER"
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

[span_2](start_span)// External reference to the global mapper defined in native-lib.cpp[span_2](end_span)
extern MapperMMC1 mapper;

[span_3](start_span)// --- RECOMPILED BANK ENTRY POINTS ---[span_3](end_span)
// These namespaces contain the execute_at function generated by the asm-to-c script.
namespace Bank00 { void execute_at(uint16_t pc); }
namespace Bank01 { void execute_at(uint16_t pc); }
namespace Bank02 { void execute_at(uint16_t pc); }
namespace Bank03 { void execute_at(uint16_t pc); }

typedef void (*BankExecFn)(uint16_t);

[span_4](start_span)// Table of function pointers for the 4 available 16KB banks[span_4](end_span)
static const BankExecFn bank_dispatch_table[] = {
    Bank00::execute_at,
    Bank01::execute_at,
    Bank02::execute_at,
    Bank03::execute_at
};

namespace Dispatcher {

    /**
     * Resolves the NES Memory Map for MMC1 and dispatches execution to 
     * [span_5](start_span)the recompiled C++ bank logic[span_5](end_span).
     */
    void execute_at(uint16_t pc) {
        if (pc >= 0x8000) {
            uint8_t mode = (mapper.control >> 2) & 0x03; [span_6](start_span)// MMC1 PRG Banking Mode[span_6](end_span)
            uint8_t bank_reg = mapper.prg_bank & 0x0F;
            uint8_t target_index = 0;

            if (pc >= 0xC000) {
                // --- Upper Window: $C000 - $FFFF ---
                switch (mode) {
                    case 0:
                    case 1: // 32KB Mode: High bank of the 32KB pair
                        target_index = (bank_reg & 0x0E) | 0x01;
                        break;
                    case 2: // $C000 is Switchable
                        target_index = bank_reg;
                        break;
                    case 3:
                    default: // $C000 is Fixed to the Last Bank (Dragon Warrior standard)
                        target_index = 3;
                        break;
                }
            } else {
                // --- Lower Window: $8000 - $BFFF ---
                switch (mode) {
                    case 0:
                    case 1: // 32KB Mode: Low bank of the 32KB pair
                        target_index = (bank_reg & 0x0E);
                        break;
                    case 2: // $8000 is Fixed to the First Bank
                        target_index = 0;
                        break;
                    case 3:
                    default: // $8000 is Switchable
                        target_index = bank_reg;
                        break;
                }
            }

            [span_7](start_span)// --- CRITICAL BOUNDS CHECK ---[span_7](end_span)
            // Dragon Warrior 1 is 64KB (4 banks). Masking prevents 
            // out-of-bounds access to the dispatch table.
            target_index &= 0x03;

            [span_8](start_span)// Call the recompiled logic for this specific bank[span_8](end_span)
            bank_dispatch_table[target_index](pc);
        } else {
            [span_9](start_span)// RAM/Register Execution: Recompiled code cannot exist here[span_9](end_span).
            [span_10](start_span)// Increment PC to prevent a hard hang[span_10](end_span).
            reg_PC++;
        }
    }

    /**
     * FIXED: Entry point for the engine loop in native-lib.cpp.
     * [span_11](start_span)This function was missing, causing the linker error[span_11](end_span).
     */
    void execute() {
        execute_at(reg_PC);
    }
}
